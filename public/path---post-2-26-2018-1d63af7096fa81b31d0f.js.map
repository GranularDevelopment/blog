{"version":3,"sources":["webpack:///path---post-2-26-2018-1d63af7096fa81b31d0f.js","webpack:///./.cache/json/post-2-26-2018.json"],"names":["webpackJsonp","515","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug","previous","fields","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,4BAAAC,OAAA,gBAA4DC,gBAAmBC,GAAA,qHAAAC,KAAA,+hWAAq4WC,aAAgIL,MAAA,sBAAAM,KAAA,uBAA2DC,aAAgBC,KAAA,mBAAAC,UAAsCC,QAAUF,KAAA,oBAA0BH,aAAgBL,MAAA,yBAAgCW,MAASD,QAAUF,KAAA,mBAAyBH,aAAgBL,MAAA","file":"path---post-2-26-2018-1d63af7096fa81b31d0f.js","sourcesContent":["webpackJsonp([231298299618886],{\n\n/***/ 515:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Granular Development Blog\",\"author\":\"Brian Smith\"}},\"markdownRemark\":{\"id\":\"/Users/briansmith/Documents/Dev/granular-blog/src/pages/post-2-26-2018/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3>Asynchronous Code</h3>\\n<p>Asynchronous code is non-blocking code, which means we can start a long-running operation without waiting while its happening. </p>\\n<h3>What is Async/Await</h3>\\n<p>In C# 5.0 the compiler team at Microsoft added a new feature in form of two keywords: </p>\\n<ul>\\n<li>Async</li>\\n<li>Await</li>\\n</ul>\\n<p>The purpose of Async/Await is to make asynchronous programming a lot easier to write by avoiding complex patterns that were necessary in previous version of C#. Even with the new async and await feature, there are still some common pitfalls.</p>\\n<h3>Best Practices</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Type</th>\\n<th>Description</th>\\n<th>Exceptions</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Avoid async void</td>\\n<td>Prefer async Task methods over async void methods</td>\\n<td>Event handlers(Button click event)</td>\\n</tr>\\n<tr>\\n<td>Async all the way</td>\\n<td>Don’t mix blocking and async code</td>\\n<td>Console main method</td>\\n</tr>\\n<tr>\\n<td>Configure context</td>\\n<td>Use ConfigureAwait(false)</td>\\n<td>Methods that require context (don’t use for methods that change the UI)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Async Void</h3>\\n<p>Async void methods primary purpose is to make asynchronous event handlers possible.</p>\\n<p>Async void methods have no Task object, therefore any exceptions will be raised directly on the SynchronizationContext.</p>\\n<p>Async void methods cannot be awaited. Async void methods are fire and forget. Async void methods will notify their SynchronizationContext when they and finish, but a custom SynchronizationContext is a complex solution for typical application code. </p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">async</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">ThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InvalidOperationException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">CallThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">ThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Failed\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<hr>\\n<p>The code fails to print “Failed”. The exception is never handled.</p>\\n<p>It’s best just to avoid async void.</p>\\n<h3>Async void lambda functions</h3>\\n<p>Even trickier case is the asynchronous lambda function to delegate method. If you use action(anonymous) delegates, the C# compiler will create an async void method, which starts the work and returns void. If you use Func<Task> delegate, the generates a function that returns Task.</p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Parallel<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">For</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">async</span> i <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>Does the code finish in 1 second, after all the tasks finish sleeping, or does it finish immediately? </p>\\n<p>The answer is you cannot know. It all depends if the delegate is an Action or Func<Task>. </p>\\n<h3>Nesting Async Code</h3>\\n<p>What do you thinks occurs here?</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Before\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span>Factory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">StartNew</span><span class=\\\"token punctuation\\\">(</span>\\n  <span class=\\\"token keyword\\\">async</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nConsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"After\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>“Before” and “After” are written right after one another, the code never waits one second.Why? The outer Task, StartNew, is the method being awaited and returns a Task<T> while theinner lambda method is returned right away with the result being a Task<Task>. The inner method is ignored.</p>\\n<p>The solution to this is to use Task.Run().</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Before\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Run</span><span class=\\\"token punctuation\\\">(</span> <span class=\\\"token keyword\\\">async</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nConsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"After\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>Remember, however, Task.Run() pools the task and the inner lambda method can be run on a background thread. Task.Run() is best suited for CPU bound work, and not used for updating the UI.</p>\\n<h3>Async all the way.</h3>\\n<p>There are no half measures with async, it’s all or nothing. What “Async all the way” means is you shouldn’t mix synchronous and asynchronous code without careful consideration. One common problem is writing  async void methods in a constructor, especially when working on GUI applications. </p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"> <span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ViewClass</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">//Not awaited!</span>\\n      <span class=\\\"token function\\\">asyncVoidMethod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n <span class=\\\"token punctuation\\\">}</span>\\n\\n <span class=\\\"token keyword\\\">async</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">asyncVoidMehtod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token comment\\\">//If the initial method is not being awaited, you might have deadlocks further down the code. </span>\\n   <span class=\\\"token keyword\\\">await</span> <span class=\\\"token function\\\">anotherAyncMethod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<hr>\\n<p> Not adhering to “async all way”, will result in code running synchronously and causing deadlocks in your application.</p>\\n<h3>Conclusion</h3>\\n<p>Async and Await greatly simplify writing asynchronous code. Personally, I love using Async and Await. I highly recommend you pick you up <a href=\\\"https://www.amazon.com/gp/product/1449367569/ref=as_li_tl?ie=UTF8&#x26;tag=granulardevel-20&#x26;camp=1789&#x26;creative=9325&#x26;linkCode=as2&#x26;creativeASIN=1449367569&#x26;linkId=4392101d23b6f64aec5e2c1744abf6f0\\\">“Concurrency in C# Cookbook: Asynchronous, Parallel, and Multithreaded Programming”</a> by Stephen Cleary  and  <a href=\\\"https://www.amazon.com/gp/product/1449337163/ref=as_li_tl?ie=UTF8&#x26;tag=granulardevel-20&#x26;camp=1789&#x26;creative=9325&#x26;linkCode=as2&#x26;creativeASIN=1449337163&#x26;linkId=9a8efc62bde5493db9e1b7c838c818d0\\\">“Async in C# 5.0: Unleash the Power of Async”</a> by Alex Davies.</p>\",\"frontmatter\":{\"title\":\"C# Async Guidelines\",\"date\":\"February 26, 2018\"}}},\"pathContext\":{\"slug\":\"/post-2-26-2018/\",\"previous\":{\"fields\":{\"slug\":\"/post-2-11-2018/\"},\"frontmatter\":{\"title\":\"Perceptron in Python\"}},\"next\":{\"fields\":{\"slug\":\"/post-3-7-2018/\"},\"frontmatter\":{\"title\":\"Xamarin Events into Commands\"}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---post-2-26-2018-1d63af7096fa81b31d0f.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Granular Development Blog\",\"author\":\"Brian Smith\"}},\"markdownRemark\":{\"id\":\"/Users/briansmith/Documents/Dev/granular-blog/src/pages/post-2-26-2018/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h3>Asynchronous Code</h3>\\n<p>Asynchronous code is non-blocking code, which means we can start a long-running operation without waiting while its happening. </p>\\n<h3>What is Async/Await</h3>\\n<p>In C# 5.0 the compiler team at Microsoft added a new feature in form of two keywords: </p>\\n<ul>\\n<li>Async</li>\\n<li>Await</li>\\n</ul>\\n<p>The purpose of Async/Await is to make asynchronous programming a lot easier to write by avoiding complex patterns that were necessary in previous version of C#. Even with the new async and await feature, there are still some common pitfalls.</p>\\n<h3>Best Practices</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>Type</th>\\n<th>Description</th>\\n<th>Exceptions</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Avoid async void</td>\\n<td>Prefer async Task methods over async void methods</td>\\n<td>Event handlers(Button click event)</td>\\n</tr>\\n<tr>\\n<td>Async all the way</td>\\n<td>Don’t mix blocking and async code</td>\\n<td>Console main method</td>\\n</tr>\\n<tr>\\n<td>Configure context</td>\\n<td>Use ConfigureAwait(false)</td>\\n<td>Methods that require context (don’t use for methods that change the UI)</td>\\n</tr>\\n</tbody>\\n</table>\\n<h3>Async Void</h3>\\n<p>Async void methods primary purpose is to make asynchronous event handlers possible.</p>\\n<p>Async void methods have no Task object, therefore any exceptions will be raised directly on the SynchronizationContext.</p>\\n<p>Async void methods cannot be awaited. Async void methods are fire and forget. Async void methods will notify their SynchronizationContext when they and finish, but a custom SynchronizationContext is a complex solution for typical application code. </p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"><span class=\\\"token keyword\\\">async</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">ThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">throw</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">InvalidOperationException</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">public</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">CallThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">try</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token function\\\">ThrowExceptionAsync</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">Exception</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Failed\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<hr>\\n<p>The code fails to print “Failed”. The exception is never handled.</p>\\n<p>It’s best just to avoid async void.</p>\\n<h3>Async void lambda functions</h3>\\n<p>Even trickier case is the asynchronous lambda function to delegate method. If you use action(anonymous) delegates, the C# compiler will create an async void method, which starts the work and returns void. If you use Func<Task> delegate, the generates a function that returns Task.</p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Parallel<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">For</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token number\\\">10</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">async</span> i <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>Does the code finish in 1 second, after all the tasks finish sleeping, or does it finish immediately? </p>\\n<p>The answer is you cannot know. It all depends if the delegate is an Action or Func<Task>. </p>\\n<h3>Nesting Async Code</h3>\\n<p>What do you thinks occurs here?</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Before\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span>Factory<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">StartNew</span><span class=\\\"token punctuation\\\">(</span>\\n  <span class=\\\"token keyword\\\">async</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nConsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"After\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>“Before” and “After” are written right after one another, the code never waits one second.Why? The outer Task, StartNew, is the method being awaited and returns a Task<T> while theinner lambda method is returned right away with the result being a Task<Task>. The inner method is ignored.</p>\\n<p>The solution to this is to use Task.Run().</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\">Console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"Before\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Run</span><span class=\\\"token punctuation\\\">(</span> <span class=\\\"token keyword\\\">async</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=</span><span class=\\\"token operator\\\">></span> <span class=\\\"token punctuation\\\">{</span> <span class=\\\"token keyword\\\">await</span> Task<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">Delay</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token number\\\">1000</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nConsole<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">WriteLine</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">\\\"After\\\"</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<hr>\\n<p>Remember, however, Task.Run() pools the task and the inner lambda method can be run on a background thread. Task.Run() is best suited for CPU bound work, and not used for updating the UI.</p>\\n<h3>Async all the way.</h3>\\n<p>There are no half measures with async, it’s all or nothing. What “Async all the way” means is you shouldn’t mix synchronous and asynchronous code without careful consideration. One common problem is writing  async void methods in a constructor, especially when working on GUI applications. </p>\\n<p>Example:</p>\\n<hr>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-csharp\\\"><code class=\\\"language-csharp\\\"> <span class=\\\"token keyword\\\">public</span> <span class=\\\"token function\\\">ViewClass</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n      <span class=\\\"token comment\\\">//Not awaited!</span>\\n      <span class=\\\"token function\\\">asyncVoidMethod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n <span class=\\\"token punctuation\\\">}</span>\\n\\n <span class=\\\"token keyword\\\">async</span> <span class=\\\"token keyword\\\">void</span> <span class=\\\"token function\\\">asyncVoidMehtod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n   <span class=\\\"token comment\\\">//If the initial method is not being awaited, you might have deadlocks further down the code. </span>\\n   <span class=\\\"token keyword\\\">await</span> <span class=\\\"token function\\\">anotherAyncMethod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n <span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<hr>\\n<p> Not adhering to “async all way”, will result in code running synchronously and causing deadlocks in your application.</p>\\n<h3>Conclusion</h3>\\n<p>Async and Await greatly simplify writing asynchronous code. Personally, I love using Async and Await. I highly recommend you pick you up <a href=\\\"https://www.amazon.com/gp/product/1449367569/ref=as_li_tl?ie=UTF8&#x26;tag=granulardevel-20&#x26;camp=1789&#x26;creative=9325&#x26;linkCode=as2&#x26;creativeASIN=1449367569&#x26;linkId=4392101d23b6f64aec5e2c1744abf6f0\\\">“Concurrency in C# Cookbook: Asynchronous, Parallel, and Multithreaded Programming”</a> by Stephen Cleary  and  <a href=\\\"https://www.amazon.com/gp/product/1449337163/ref=as_li_tl?ie=UTF8&#x26;tag=granulardevel-20&#x26;camp=1789&#x26;creative=9325&#x26;linkCode=as2&#x26;creativeASIN=1449337163&#x26;linkId=9a8efc62bde5493db9e1b7c838c818d0\\\">“Async in C# 5.0: Unleash the Power of Async”</a> by Alex Davies.</p>\",\"frontmatter\":{\"title\":\"C# Async Guidelines\",\"date\":\"February 26, 2018\"}}},\"pathContext\":{\"slug\":\"/post-2-26-2018/\",\"previous\":{\"fields\":{\"slug\":\"/post-2-11-2018/\"},\"frontmatter\":{\"title\":\"Perceptron in Python\"}},\"next\":{\"fields\":{\"slug\":\"/post-3-7-2018/\"},\"frontmatter\":{\"title\":\"Xamarin Events into Commands\"}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/post-2-26-2018.json\n// module id = 515\n// module chunks = 231298299618886"],"sourceRoot":""}